// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "./ADCDEXFactory.sol";
import "./ADCDEX.sol";

contract ADCDEXRouter is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    ADCDEXFactory public factory;

    function initialize(address _factory, address _owner) public initializer {
        __Ownable_init(_owner);
        __UUPSUpgradeable_init();
        factory = ADCDEXFactory(_factory);
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    /**
     * @notice Add liquidity to a pair pool
     * @param tokenA Token A address
     * @param tokenB Token B address
     * @param amountA Amount of Token A to add
     * @param amountB Amount of Token B to add
     * @return lpTokens The amount of LP tokens minted
     */
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountA,
        uint256 amountB
    ) external returns (uint256 lpTokens) {
        address pair = factory.getPair(tokenA, tokenB);
        require(pair != address(0), "Pair does not exist");

        IERC20Upgradeable(tokenA).transferFrom(msg.sender, pair, amountA);
        IERC20Upgradeable(tokenB).transferFrom(msg.sender, pair, amountB);

        lpTokens = ADCDEX(pair).addLiquidity(amountA, amountB);
    }

    /**
     * @notice Swap exact input tokens for output tokens
     * @param inputToken Token user is sending in
     * @param outputToken Token user wants out
     * @param inputAmount Amount of input token
     * @param minOutputAmount Minimum acceptable output (slippage protection)
     * @return outputAmount Amount of output token received
     */
    function swapExactTokensForTokens(
        address inputToken,
        address outputToken,
        uint256 inputAmount,
        uint256 minOutputAmount
    ) external returns (uint256 outputAmount) {
        address pair = factory.getPair(inputToken, outputToken);
        require(pair != address(0), "Pair does not exist");

        // Transfer input token to the pair contract
        IERC20Upgradeable(inputToken).transferFrom(msg.sender, pair, inputAmount);

        // Determine swap direction based on ADCDEX pair's adcToken
        address adcTokenAddress = address(ADCDEX(pair).adcToken());

        if (inputToken == adcTokenAddress) {
            outputAmount = ADCDEX(pair).swapADCForStable(inputAmount);
        } else if (outputToken == adcTokenAddress) {
            outputAmount = ADCDEX(pair).swapStableForADC(inputAmount);
        } else {
            revert("Invalid token pair for swap");
        }

        require(outputAmount >= minOutputAmount, "Slippage too high");

        // Transfer output tokens to user
        IERC20Upgradeable(outputToken).transfer(msg.sender, outputAmount);
    }
}
